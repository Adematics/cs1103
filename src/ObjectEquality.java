/**
 * Having to compare objects it's something very common while programming, so having equals method implemented in the
 * Object class it's a great advantage. Since all classes inherits from it, we have on our hands the power to override
 * the equals method to compare an object in a way that best fits our needs for a given scenario. Like the following
 * example:
 */

//class Person {
//    String name;
//    Double age;
//
//    Person(String name, Double age) {
//        this.name = name;
//        this.age = age;
//    }
//
//    @Override
//    public boolean equals(Object obj) {
//        if (this == obj) return true;
//        if (!(obj instanceof Person)) return false;
//        Person person = (Person) obj;
//        return name.equals(person.name) && age.equals(person.age);
//    }
//}
//
//public class ObjectEquality {
//    public static void main(String[] args) {
//        Person person1 = new Person("Manuela", 22.0);
//        Person person2 = new Person("Manuela", 22.0);
//
//        System.out.println("Reference equality: " + (person1 == person2));
//        System.out.println("Content equality: " + person1.equals(person2));
//    }
//}

/**
 * While "==" operator compares two objects by validating if they points to the same memory address, the Person.equals
 * method overrides Object.equals() behavior and it validates if the received object have the same type, if it does,
 * it validates if all fields have the same content, which makes more sense for our scenario.
 * if the Person.equals() method is deleted, the return will be:
 * <p>
 * Reference equality: false
 * Content equality: false
 * <p>
 * instead of the expected
 * <p>
 * Reference equality: false
 * Content equality: true
 * PS: The Person.equals() method was automatically generated by IntelliJ IDE.
 */

/** PS: The Person.equals() method was automatically generated by IntelliJ IDE. */


/**
 One disadvantage is to get confused about the equals method implementation by some external code, and ended up doing
 a reference comparison instead of something else, like in the following example:
 */

public class ObjectEquality {
    public static void main(String[] args) {
        StringBuilder string1 = new StringBuilder();
        string1.append("string");

        StringBuilder string2 = new StringBuilder();
        string2.append("string");

        System.out.println("StringBuilder.equals() inheriting Object.equals(): " + string1.equals(string2));
        System.out.println("Reference equality: " + (string1 == string2));
        System.out.println("String.equals(): " + string1.toString().equals(string2.toString()));
    }
}

/**
 The StringBuilder class does not overrides Object.equals() while the String class does. This can be very tricky and
 I think that the best way to avoid this is to consult Java's documentation about the implemented behavior for a given
 class and to always cover your code with tests.
 */

